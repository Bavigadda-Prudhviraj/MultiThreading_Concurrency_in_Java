All About:-
	1.Creating threads and providing the code that gets executes by thread
	2.Accessing common data and code through synchronization
	3.Transitioning between threads states.

Multitasking:-
	Multitasking allows several activities to occur on the computer
	There are two types of multitasking are there in computer:-
		1.Process-based multitasking
		2.Thread-based multitasking
		
	1.Process-based multitasking:-
		Allows processes(i.e programs) to run concurrently on the computer.
		Example:- Running the Ms paint while also working with the word processor
	
	2.Thread-based multitasking
		Allows parts of the same program to run concurrently on the computer
		Example:- Ms word that is painting and formatting text at the same time
				  In Ms word while typing at the same time internally it check spell check check happens
		note:- why threads are better then processes
			   1. Two threads share the same address space
			   2. Context switching between threads is usually less expensive than between processes
			   3. The cost of communication between threads is relatively low.
			   
			   
Why MultiThreading?
	1.In a single-threaded environment, only one task at a time can be  performed.
	2.CPU cycles are wasted,for example, when waiting for user input.
	3.Multitasking allows idle CPU time to be put to good use.

Threads:-
	1.A thread is an independent sequential path of execution with in a program
	2.Many Threads can run concurrently within one program
	3.At runtime, thread is a program exist in a common memory space and can, therefore, share both data and code( i.e., they are lightweight compared to processes)
	4.In Java, the main class automatically includes a main thread, so there is no need to explicitly create it
	5.They also share the process running the program.
	
The Main Thread:-
	1.When a standAlone application is run, a user thread is automatically created to execute the main() method of the application
	  This thread is called the main thread
	2.If no Other user threads are spawned, the program terminates when the main() method finished executing
	3.All Other threads, called child threads, are spawned from the main thread
	4.The main() method can then finish, but the program will keep running until all user threads have completed.
	5.The runtime environment distinguishes between user-thread & daemon threads.
	Note:- main is also an user thread
	6.Calling the setDaemon(boolean) method in the thread class marks the status of the thread as either daemon of user,
	  but this must be done before the thread is start.
	7.As long as a User thread is alive, the JVM does not terminate.
	8.A daemon thread is at the mercy of the running system:- it is stopped
	  if there are no more user threads running, thus terminating the program
	  (program will terminate after all user threads are done, even daemon thread is running)
	  
Thread Creation:-
	1.A thread in java is represented by an object of the Thread class.
	2.Creating threads is achieved in one of two ways.
		i. Implementing the " java.lang.Runnable interface ". ( best way )
		ii.Extending the " java.lang.Thread class ".( Note:- thread class is also implements runnable ).
	
	imp:-
		which thread creation is best in java thread class or runnable interface
		1.if we use thread, it is already extending the thread class,if we need extend other class it is not possible due to diamond problem.so we can't extent multiple classes.
		2.if we use runnable interface, we can implement as many as interfaces and extend one class
		
	
	

Synchronization:-
	1.Threads share the same memory space, i.e. they can share resource( objects )
	2.However, there are critical  situation, where it is desirable that only one thread at a time has access to a shared resource
	  example:- booking ticked for movie left one seat, so one thread has to access that seat even many threads try to access,that time synchronization helps
	3.To handle critical situation like above example synchronization comes into picture. 
	  

Synchronized Methods:
	1.while a thread is inside a Synchronized method of an object, all other threads that wish to execute "this" synchronized method or any other Synchronized method of the other object will have to wait.
	2.This restriction does not apply to the thread that already has the lock and is executing a Synchronized method of the object
	3.Such a method can invoke other Synchronized methods of the object without being blocked.
	4.The non-Synchronized methods of the object can always be called at any time by any thread.

Rules of Synchronization:
	1.A thread must acquire the object lock associate with a shared resource it can enter the shared resource
	2.The runtime system ensures that no other thread lock can enter a shared resource.if another thread already holds the object lock associated with it.
	3.If a thread cannot immediately acquire the object lick,it is blocked, i.e., it must wait for the lock to become available.
	4.when a thread exits a shared resource, the runtime system ensures that the object lock is also relinquished.if another thread is waiting for this object lock,
	  it can try to acquire the lock in order to gain access to shared resource.
	
	5.It should be made clear that programs should not make any assumptions about the order in which threads are granted ownership of a lock, it will taken care by the CPU scheduling or whatever GBM

Static Synchronized Methods:
	1.In class one is static synchronized method and another one is Synchronized block inside the method then both are not Synchronized
	2.because static method has lock(className.class) current object, and Synchronized block lock(this) is we are explicitly written.so both are different no Synchronized will happen
	3.In Other words, Synchronization of static methods in a class is independent form the Synchronization of instance methods on objects of the class.
	4.A Subclass decides whether the new definition of an inherited Synchronized method will remain synchronized in the subclass

Race Condition:
	It occurs when two or more threads simultaneously update the same value(StackTopIndex in our case)ans, as a consequence,leave the values in an undefined or inconsistent state
	
Synchronization Summary:
	A thread can hold a lock on an object:
		1.By executing a Synchronized instance method of the object.(this)
		2.By executing the body of a Synchronized block that Synchronizes on the object.(this)
		3.By executing a Synchronized static method of a class or a block inside a static method( in which case, the object is the Class Object representing the class in the JVM)
		
Thread safety:
	1.It's the term used to describe the design of classes that ensure that the state of their objects is always consistent,even when objects are used concurrently by multiple threads.
		Example:- StringBuffer
		
Volatile ( imp for SDE-2 Interviews ):-
	1.It is used in singleton pattern
	2.It is a key word in java
	3.Example: 1.if we have two threads,it interacts with CPU,Internally CPU interact with main memory RAM
			   2.Now "Cache" comes into picture.it reduces the access time.It is for more efficient for CPU to access data from cache than for CPU accessing the data from main memory
			   3.When there is a shared variable ( flag-T ). you can consider the top of the stack in Synchronized example.that is a shared variable
			   4.Because that shared variable exists in the main memory and multiple thread trying to access that variable and work on it
			   Example:- 1.Let us consider an example of shared boolean variable that in initially set true 
			   			 2.when two threads,When both threads they don't read from the memory,They have there own cash,they read these threads read the value of this flag variable locally from their cache
			   			 3.Now problem might happen is,If one thread changes the values of cache to false,it wont update directly into the RAM.First it update in its local cache
			   			 4.when other thread which is accessing the cache that will be TRUE only,because it is not updated in local cash,as well as in the main memory it will be true only
			   			 5.it will take some time to update cache values false in main memory(RAM),updation done by thread two.
			   			 6.To get ride of the problem we introduce the volatile key word
			   			 7.Volatile:- 1.now we declare that shared variable as volatile
			   			 			  2.From now onwards it word read the data from cache, it read the shared variable from the main memory only( RAM );
			   			 			  3.If thread two changes the state of the volatile shared variable them then one will have access to it right
			   			 			  Example:- to more about volatile go through the singleton design pattern repository
			   